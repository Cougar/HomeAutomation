   1               		.file	"uart.c"
   2               		.arch atmega8
   3               	__SREG__ = 0x3f
   4               	__SP_H__ = 0x3e
   5               	__SP_L__ = 0x3d
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
  84               	.global	__vector_11
  86               	__vector_11:
   1:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
   2:../avr-lib/drivers/uart/uart.c **** Title:    Interrupt UART library with receive/transmit circular buffers
   3:../avr-lib/drivers/uart/uart.c **** Author:   Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   4:../avr-lib/drivers/uart/uart.c **** File:     $Id: uart.c,v 1.5.2.10 2005/11/15 19:49:12 peter Exp $
   5:../avr-lib/drivers/uart/uart.c **** Software: AVR-GCC 3.3 
   6:../avr-lib/drivers/uart/uart.c **** Hardware: any AVR with built-in UART, 
   7:../avr-lib/drivers/uart/uart.c ****           tested on AT90S8515 at 4 Mhz and ATmega at 1Mhz
   8:../avr-lib/drivers/uart/uart.c **** 
   9:../avr-lib/drivers/uart/uart.c **** DESCRIPTION:
  10:../avr-lib/drivers/uart/uart.c ****     An interrupt is generated when the UART has finished transmitting or
  11:../avr-lib/drivers/uart/uart.c ****     receiving a byte. The interrupt handling routines use circular buffers
  12:../avr-lib/drivers/uart/uart.c ****     for buffering received and transmitted data.
  13:../avr-lib/drivers/uart/uart.c ****     
  14:../avr-lib/drivers/uart/uart.c ****     The UART_RX_BUFFER_SIZE and UART_TX_BUFFER_SIZE variables define
  15:../avr-lib/drivers/uart/uart.c ****     the buffer size in bytes. Note that these variables must be a 
  16:../avr-lib/drivers/uart/uart.c ****     power of 2.
  17:../avr-lib/drivers/uart/uart.c ****     
  18:../avr-lib/drivers/uart/uart.c **** USAGE:
  19:../avr-lib/drivers/uart/uart.c ****     Refere to the header file uart.h for a description of the routines. 
  20:../avr-lib/drivers/uart/uart.c ****     See also example test_uart.c.
  21:../avr-lib/drivers/uart/uart.c **** 
  22:../avr-lib/drivers/uart/uart.c **** NOTES:
  23:../avr-lib/drivers/uart/uart.c ****     Based on Atmel Application Note AVR306
  24:../avr-lib/drivers/uart/uart.c ****                     
  25:../avr-lib/drivers/uart/uart.c **** *************************************************************************/
  26:../avr-lib/drivers/uart/uart.c **** #include <avr/io.h>
  27:../avr-lib/drivers/uart/uart.c **** #include <avr/interrupt.h>
  28:../avr-lib/drivers/uart/uart.c **** #include <avr/pgmspace.h>
  29:../avr-lib/drivers/uart/uart.c **** #include <drivers/uart/uart.h>
  30:../avr-lib/drivers/uart/uart.c **** 
  31:../avr-lib/drivers/uart/uart.c **** 
  32:../avr-lib/drivers/uart/uart.c **** /*
  33:../avr-lib/drivers/uart/uart.c ****  *  constants and macros
  34:../avr-lib/drivers/uart/uart.c ****  */
  35:../avr-lib/drivers/uart/uart.c **** 
  36:../avr-lib/drivers/uart/uart.c **** /* size of RX/TX buffers */
  37:../avr-lib/drivers/uart/uart.c **** #define UART_RX_BUFFER_MASK ( UART_RX_BUFFER_SIZE - 1)
  38:../avr-lib/drivers/uart/uart.c **** #define UART_TX_BUFFER_MASK ( UART_TX_BUFFER_SIZE - 1)
  39:../avr-lib/drivers/uart/uart.c **** 
  40:../avr-lib/drivers/uart/uart.c **** #if ( UART_RX_BUFFER_SIZE & UART_RX_BUFFER_MASK )
  41:../avr-lib/drivers/uart/uart.c **** #error RX buffer size is not a power of 2
  42:../avr-lib/drivers/uart/uart.c **** #endif
  43:../avr-lib/drivers/uart/uart.c **** #if ( UART_TX_BUFFER_SIZE & UART_TX_BUFFER_MASK )
  44:../avr-lib/drivers/uart/uart.c **** #error TX buffer size is not a power of 2
  45:../avr-lib/drivers/uart/uart.c **** #endif
  46:../avr-lib/drivers/uart/uart.c **** 
  47:../avr-lib/drivers/uart/uart.c **** #if defined(__AVR_AT90S2313__) \
  48:../avr-lib/drivers/uart/uart.c ****  || defined(__AVR_AT90S4414__) || defined(__AVR_AT90S4434__) \
  49:../avr-lib/drivers/uart/uart.c ****  || defined(__AVR_AT90S8515__) || defined(__AVR_AT90S8535__) \
  50:../avr-lib/drivers/uart/uart.c ****  || defined(__AVR_ATmega103__)
  51:../avr-lib/drivers/uart/uart.c ****  /* old AVR classic or ATmega103 with one UART */
  52:../avr-lib/drivers/uart/uart.c ****  #define AT90_UART
  53:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  54:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  55:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   USR
  56:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCR
  57:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR  
  58:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
  59:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_AT90S2333__) || defined(__AVR_AT90S4433__)
  60:../avr-lib/drivers/uart/uart.c ****  /* old AVR classic with one UART */
  61:../avr-lib/drivers/uart/uart.c ****  #define AT90_UART
  62:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  63:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  64:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSRA
  65:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSRB
  66:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR 
  67:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
  68:../avr-lib/drivers/uart/uart.c **** #elif  defined(__AVR_ATmega8__)  || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
  69:../avr-lib/drivers/uart/uart.c ****   || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__) \
  70:../avr-lib/drivers/uart/uart.c ****   || defined(__AVR_ATmega323__)
  71:../avr-lib/drivers/uart/uart.c ****   /* ATmega with one USART */
  72:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART
  73:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  74:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  75:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSRA
  76:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSRB
  77:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR
  78:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
  79:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega163__) 
  80:../avr-lib/drivers/uart/uart.c ****   /* ATmega163 with one UART */
  81:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_UART
  82:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART_RECV
  83:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART_DATA
  84:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSRA
  85:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSRB
  86:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR
  87:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
  88:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega162__)
  89:../avr-lib/drivers/uart/uart.c ****  /* ATmega with two USART */
  90:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART0
  91:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART1
  92:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RECV
  93:../avr-lib/drivers/uart/uart.c ****  #define UART1_RECEIVE_INTERRUPT   SIG_USART1_RECV
  94:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_DATA
  95:../avr-lib/drivers/uart/uart.c ****  #define UART1_TRANSMIT_INTERRUPT  SIG_USART1_DATA
  96:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSR0A
  97:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSR0B
  98:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR0
  99:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE0
 100:../avr-lib/drivers/uart/uart.c ****  #define UART1_STATUS   UCSR1A
 101:../avr-lib/drivers/uart/uart.c ****  #define UART1_CONTROL  UCSR1B
 102:../avr-lib/drivers/uart/uart.c ****  #define UART1_DATA     UDR1
 103:../avr-lib/drivers/uart/uart.c ****  #define UART1_UDRIE    UDRIE1
 104:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) 
 105:../avr-lib/drivers/uart/uart.c ****  /* ATmega with two USART */
 106:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART0
 107:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART1
 108:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_UART0_RECV
 109:../avr-lib/drivers/uart/uart.c ****  #define UART1_RECEIVE_INTERRUPT   SIG_UART1_RECV
 110:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_UART0_DATA
 111:../avr-lib/drivers/uart/uart.c ****  #define UART1_TRANSMIT_INTERRUPT  SIG_UART1_DATA
 112:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSR0A
 113:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSR0B
 114:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR0
 115:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE0
 116:../avr-lib/drivers/uart/uart.c ****  #define UART1_STATUS   UCSR1A
 117:../avr-lib/drivers/uart/uart.c ****  #define UART1_CONTROL  UCSR1B
 118:../avr-lib/drivers/uart/uart.c ****  #define UART1_DATA     UDR1
 119:../avr-lib/drivers/uart/uart.c ****  #define UART1_UDRIE    UDRIE1
 120:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega161__)
 121:../avr-lib/drivers/uart/uart.c ****  /* ATmega with UART */
 122:../avr-lib/drivers/uart/uart.c ****  #error "AVR ATmega161 currently not supported by this libaray !"
 123:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega169__) 
 124:../avr-lib/drivers/uart/uart.c ****  /* ATmega with one USART */
 125:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART
 126:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 127:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 128:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSRA
 129:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSRB
 130:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR
 131:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
 132:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATmega48__) ||defined(__AVR_ATmega88__) || defined(__AVR_ATmega168__)
 133:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART0
 134:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART_RECV
 135:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART_DATA
 136:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSR0A
 137:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSR0B
 138:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR0
 139:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE0
 140:../avr-lib/drivers/uart/uart.c **** #elif defined(__AVR_ATtiny2313__)
 141:../avr-lib/drivers/uart/uart.c ****  #define ATMEGA_USART
 142:../avr-lib/drivers/uart/uart.c ****  #define UART0_RECEIVE_INTERRUPT   SIG_USART0_RX 
 143:../avr-lib/drivers/uart/uart.c ****  #define UART0_TRANSMIT_INTERRUPT  SIG_USART0_UDRE
 144:../avr-lib/drivers/uart/uart.c ****  #define UART0_STATUS   UCSRA
 145:../avr-lib/drivers/uart/uart.c ****  #define UART0_CONTROL  UCSRB
 146:../avr-lib/drivers/uart/uart.c ****  #define UART0_DATA     UDR
 147:../avr-lib/drivers/uart/uart.c ****  #define UART0_UDRIE    UDRIE
 148:../avr-lib/drivers/uart/uart.c **** #else
 149:../avr-lib/drivers/uart/uart.c ****  #error "no UART definition for MCU available"
 150:../avr-lib/drivers/uart/uart.c **** #endif
 151:../avr-lib/drivers/uart/uart.c **** 
 152:../avr-lib/drivers/uart/uart.c **** 
 153:../avr-lib/drivers/uart/uart.c **** /*
 154:../avr-lib/drivers/uart/uart.c ****  *  module global variables
 155:../avr-lib/drivers/uart/uart.c ****  */
 156:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_TxBuf[UART_TX_BUFFER_SIZE];
 157:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_RxBuf[UART_RX_BUFFER_SIZE];
 158:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_TxHead;
 159:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_TxTail;
 160:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_RxHead;
 161:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_RxTail;
 162:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART_LastRxError;
 163:../avr-lib/drivers/uart/uart.c **** 
 164:../avr-lib/drivers/uart/uart.c **** #if defined( ATMEGA_USART1 )
 165:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_TxBuf[UART_TX_BUFFER_SIZE];
 166:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_RxBuf[UART_RX_BUFFER_SIZE];
 167:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_TxHead;
 168:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_TxTail;
 169:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_RxHead;
 170:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_RxTail;
 171:../avr-lib/drivers/uart/uart.c **** static volatile unsigned char UART1_LastRxError;
 172:../avr-lib/drivers/uart/uart.c **** #endif
 173:../avr-lib/drivers/uart/uart.c **** 
 174:../avr-lib/drivers/uart/uart.c **** 
 175:../avr-lib/drivers/uart/uart.c **** 
 176:../avr-lib/drivers/uart/uart.c **** SIGNAL(UART0_RECEIVE_INTERRUPT)
 177:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 178:../avr-lib/drivers/uart/uart.c **** Function: UART Receive Complete interrupt
 179:../avr-lib/drivers/uart/uart.c **** Purpose:  called when the UART has received a character
 180:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 181:../avr-lib/drivers/uart/uart.c **** {
  88               	.LM0:
  89               	/* prologue: frame size=0 */
  90 0000 1F92      		push __zero_reg__
  91 0002 0F92      		push __tmp_reg__
  92 0004 0FB6      		in __tmp_reg__,__SREG__
  93 0006 0F92      		push __tmp_reg__
  94 0008 1124      		clr __zero_reg__
  95 000a 2F93      		push r18
  96 000c 8F93      		push r24
  97 000e 9F93      		push r25
  98 0010 EF93      		push r30
  99 0012 FF93      		push r31
 100               	/* prologue end (size=10) */
 182:../avr-lib/drivers/uart/uart.c ****     unsigned char tmphead;
 183:../avr-lib/drivers/uart/uart.c ****     unsigned char data;
 184:../avr-lib/drivers/uart/uart.c ****     unsigned char usr;
 185:../avr-lib/drivers/uart/uart.c ****     unsigned char lastRxError;
 186:../avr-lib/drivers/uart/uart.c ****  
 187:../avr-lib/drivers/uart/uart.c ****  
 188:../avr-lib/drivers/uart/uart.c ****     /* read UART status register and UART data register */ 
 189:../avr-lib/drivers/uart/uart.c ****     usr  = UART0_STATUS;
 102               	.LM1:
 103 0014 9BB1      		in r25,43-0x20
 190:../avr-lib/drivers/uart/uart.c ****     data = UART0_DATA;
 105               	.LM2:
 106 0016 2CB1      		in r18,44-0x20
 191:../avr-lib/drivers/uart/uart.c ****     
 192:../avr-lib/drivers/uart/uart.c ****     /* */
 193:../avr-lib/drivers/uart/uart.c **** #if defined( AT90_UART )
 194:../avr-lib/drivers/uart/uart.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 195:../avr-lib/drivers/uart/uart.c **** #elif defined( ATMEGA_USART )
 196:../avr-lib/drivers/uart/uart.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 197:../avr-lib/drivers/uart/uart.c **** #elif defined( ATMEGA_USART0 )
 198:../avr-lib/drivers/uart/uart.c ****     lastRxError = (usr & (_BV(FE0)|_BV(DOR0)) );
 199:../avr-lib/drivers/uart/uart.c **** #elif defined ( ATMEGA_UART )
 200:../avr-lib/drivers/uart/uart.c ****     lastRxError = (usr & (_BV(FE)|_BV(DOR)) );
 201:../avr-lib/drivers/uart/uart.c **** #endif
 202:../avr-lib/drivers/uart/uart.c ****         
 203:../avr-lib/drivers/uart/uart.c ****     /* calculate buffer index */ 
 204:../avr-lib/drivers/uart/uart.c ****     tmphead = ( UART_RxHead + 1) & UART_RX_BUFFER_MASK;
 108               	.LM3:
 109 0018 E091 0000 		lds r30,UART_RxHead
 110 001c EF5F      		subi r30,lo8(-(1))
 111 001e EF71      		andi r30,lo8(31)
 205:../avr-lib/drivers/uart/uart.c ****     
 206:../avr-lib/drivers/uart/uart.c ****     if ( tmphead == UART_RxTail ) {
 113               	.LM4:
 114 0020 8091 0000 		lds r24,UART_RxTail
 115 0024 E817      		cp r30,r24
 116 0026 11F4      		brne .L2
 118               	.LM5:
 119 0028 82E0      		ldi r24,lo8(2)
 120 002a 08C0      		rjmp .L4
 121               	.L2:
 123               	.LM6:
 124 002c 892F      		mov r24,r25
 125 002e 8871      		andi r24,lo8(24)
 207:../avr-lib/drivers/uart/uart.c ****         /* error: receive buffer overflow */
 208:../avr-lib/drivers/uart/uart.c ****         lastRxError = UART_BUFFER_OVERFLOW >> 8;
 209:../avr-lib/drivers/uart/uart.c ****     }else{
 210:../avr-lib/drivers/uart/uart.c ****         /* store new index */
 211:../avr-lib/drivers/uart/uart.c ****         UART_RxHead = tmphead;
 127               	.LM7:
 128 0030 E093 0000 		sts UART_RxHead,r30
 212:../avr-lib/drivers/uart/uart.c ****         /* store received data in buffer */
 213:../avr-lib/drivers/uart/uart.c ****         UART_RxBuf[tmphead] = data;
 130               	.LM8:
 131 0034 FF27      		clr r31
 132 0036 E050      		subi r30,lo8(-(UART_RxBuf))
 133 0038 F040      		sbci r31,hi8(-(UART_RxBuf))
 134 003a 2083      		st Z,r18
 135               	.L4:
 214:../avr-lib/drivers/uart/uart.c ****     }
 215:../avr-lib/drivers/uart/uart.c ****     UART_LastRxError = lastRxError;   
 137               	.LM9:
 138 003c 8093 0000 		sts UART_LastRxError,r24
 139               	/* epilogue: frame size=0 */
 140 0040 FF91      		pop r31
 141 0042 EF91      		pop r30
 142 0044 9F91      		pop r25
 143 0046 8F91      		pop r24
 144 0048 2F91      		pop r18
 145 004a 0F90      		pop __tmp_reg__
 146 004c 0FBE      		out __SREG__,__tmp_reg__
 147 004e 0F90      		pop __tmp_reg__
 148 0050 1F90      		pop __zero_reg__
 149 0052 1895      		reti
 150               	/* epilogue end (size=10) */
 151               	/* function __vector_11 size 42 (22) */
 159               	.Lscope0:
 161               	.global	__vector_12
 163               	__vector_12:
 216:../avr-lib/drivers/uart/uart.c **** }
 217:../avr-lib/drivers/uart/uart.c **** 
 218:../avr-lib/drivers/uart/uart.c **** 
 219:../avr-lib/drivers/uart/uart.c **** SIGNAL(UART0_TRANSMIT_INTERRUPT)
 220:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 221:../avr-lib/drivers/uart/uart.c **** Function: UART Data Register Empty interrupt
 222:../avr-lib/drivers/uart/uart.c **** Purpose:  called when the UART is ready to transmit the next byte
 223:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 224:../avr-lib/drivers/uart/uart.c **** {
 165               	.LM10:
 166               	/* prologue: frame size=0 */
 167 0054 1F92      		push __zero_reg__
 168 0056 0F92      		push __tmp_reg__
 169 0058 0FB6      		in __tmp_reg__,__SREG__
 170 005a 0F92      		push __tmp_reg__
 171 005c 1124      		clr __zero_reg__
 172 005e 8F93      		push r24
 173 0060 9F93      		push r25
 174 0062 EF93      		push r30
 175 0064 FF93      		push r31
 176               	/* prologue end (size=9) */
 225:../avr-lib/drivers/uart/uart.c ****     unsigned char tmptail;
 226:../avr-lib/drivers/uart/uart.c **** 
 227:../avr-lib/drivers/uart/uart.c ****     
 228:../avr-lib/drivers/uart/uart.c ****     if ( UART_TxHead != UART_TxTail) {
 178               	.LM11:
 179 0066 9091 0000 		lds r25,UART_TxHead
 180 006a 8091 0000 		lds r24,UART_TxTail
 181 006e 9817      		cp r25,r24
 182 0070 61F0      		breq .L7
 229:../avr-lib/drivers/uart/uart.c ****         /* calculate and store new buffer index */
 230:../avr-lib/drivers/uart/uart.c ****         tmptail = (UART_TxTail + 1) & UART_TX_BUFFER_MASK;
 184               	.LM12:
 185 0072 E091 0000 		lds r30,UART_TxTail
 186 0076 EF5F      		subi r30,lo8(-(1))
 187 0078 EF71      		andi r30,lo8(31)
 231:../avr-lib/drivers/uart/uart.c ****         UART_TxTail = tmptail;
 189               	.LM13:
 190 007a E093 0000 		sts UART_TxTail,r30
 232:../avr-lib/drivers/uart/uart.c ****         /* get one byte from buffer and write it to UART */
 233:../avr-lib/drivers/uart/uart.c ****         UART0_DATA = UART_TxBuf[tmptail];  /* start transmission */
 192               	.LM14:
 193 007e FF27      		clr r31
 194 0080 E050      		subi r30,lo8(-(UART_TxBuf))
 195 0082 F040      		sbci r31,hi8(-(UART_TxBuf))
 196 0084 8081      		ld r24,Z
 197 0086 8CB9      		out 44-0x20,r24
 198 0088 01C0      		rjmp .L10
 199               	.L7:
 234:../avr-lib/drivers/uart/uart.c ****     }else{
 235:../avr-lib/drivers/uart/uart.c ****         /* tx buffer empty, disable UDRE interrupt */
 236:../avr-lib/drivers/uart/uart.c ****         UART0_CONTROL &= ~_BV(UART0_UDRIE);
 201               	.LM15:
 202 008a 5598      		cbi 42-0x20,5
 203               	.L10:
 204               	/* epilogue: frame size=0 */
 205 008c FF91      		pop r31
 206 008e EF91      		pop r30
 207 0090 9F91      		pop r25
 208 0092 8F91      		pop r24
 209 0094 0F90      		pop __tmp_reg__
 210 0096 0FBE      		out __SREG__,__tmp_reg__
 211 0098 0F90      		pop __tmp_reg__
 212 009a 1F90      		pop __zero_reg__
 213 009c 1895      		reti
 214               	/* epilogue end (size=9) */
 215               	/* function __vector_12 size 37 (19) */
 220               	.Lscope1:
 223               	.global	uart_init
 225               	uart_init:
 237:../avr-lib/drivers/uart/uart.c ****     }
 238:../avr-lib/drivers/uart/uart.c **** }
 239:../avr-lib/drivers/uart/uart.c **** 
 240:../avr-lib/drivers/uart/uart.c **** 
 241:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 242:../avr-lib/drivers/uart/uart.c **** Function: uart_init()
 243:../avr-lib/drivers/uart/uart.c **** Purpose:  initialize UART and set baudrate
 244:../avr-lib/drivers/uart/uart.c **** Input:    baudrate using macro UART_BAUD_SELECT()
 245:../avr-lib/drivers/uart/uart.c **** Returns:  none
 246:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 247:../avr-lib/drivers/uart/uart.c **** void uart_init(unsigned int baudrate)
 248:../avr-lib/drivers/uart/uart.c **** {
 227               	.LM16:
 228               	/* prologue: frame size=0 */
 229               	/* prologue end (size=0) */
 230 009e 9C01      		movw r18,r24
 249:../avr-lib/drivers/uart/uart.c ****     UART_TxHead = 0;
 232               	.LM17:
 233 00a0 1092 0000 		sts UART_TxHead,__zero_reg__
 250:../avr-lib/drivers/uart/uart.c ****     UART_TxTail = 0;
 235               	.LM18:
 236 00a4 1092 0000 		sts UART_TxTail,__zero_reg__
 251:../avr-lib/drivers/uart/uart.c ****     UART_RxHead = 0;
 238               	.LM19:
 239 00a8 1092 0000 		sts UART_RxHead,__zero_reg__
 252:../avr-lib/drivers/uart/uart.c ****     UART_RxTail = 0;
 241               	.LM20:
 242 00ac 1092 0000 		sts UART_RxTail,__zero_reg__
 253:../avr-lib/drivers/uart/uart.c ****     
 254:../avr-lib/drivers/uart/uart.c **** #if defined( AT90_UART )
 255:../avr-lib/drivers/uart/uart.c ****     /* set baud rate */
 256:../avr-lib/drivers/uart/uart.c ****     UBRR = (unsigned char)baudrate; 
 257:../avr-lib/drivers/uart/uart.c **** 
 258:../avr-lib/drivers/uart/uart.c ****     /* enable UART receiver and transmmitter and receive complete interrupt */
 259:../avr-lib/drivers/uart/uart.c ****     UART0_CONTROL = _BV(RXCIE)|_BV(RXEN)|_BV(TXEN);
 260:../avr-lib/drivers/uart/uart.c **** 
 261:../avr-lib/drivers/uart/uart.c **** #elif defined (ATMEGA_USART)
 262:../avr-lib/drivers/uart/uart.c ****     /* Set baud rate */
 263:../avr-lib/drivers/uart/uart.c ****     if ( baudrate & 0x8000 )
 244               	.LM21:
 245 00b0 97FF      		sbrs r25,7
 246 00b2 03C0      		rjmp .L12
 264:../avr-lib/drivers/uart/uart.c ****     {
 265:../avr-lib/drivers/uart/uart.c ****     	 UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 248               	.LM22:
 249 00b4 82E0      		ldi r24,lo8(2)
 250 00b6 8BB9      		out 43-0x20,r24
 266:../avr-lib/drivers/uart/uart.c ****     	 baudrate &= ~0x8000;
 252               	.LM23:
 253 00b8 3F77      		andi r19,hi8(32767)
 254               	.L12:
 267:../avr-lib/drivers/uart/uart.c ****     }
 268:../avr-lib/drivers/uart/uart.c ****     UBRRH = (unsigned char)(baudrate>>8);
 256               	.LM24:
 257 00ba 832F      		mov r24,r19
 258 00bc 9927      		clr r25
 259 00be 80BD      		out 64-0x20,r24
 269:../avr-lib/drivers/uart/uart.c ****     UBRRL = (unsigned char) baudrate;
 261               	.LM25:
 262 00c0 29B9      		out 41-0x20,r18
 270:../avr-lib/drivers/uart/uart.c ****    
 271:../avr-lib/drivers/uart/uart.c ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 272:../avr-lib/drivers/uart/uart.c ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 264               	.LM26:
 265 00c2 88E9      		ldi r24,lo8(-104)
 266 00c4 8AB9      		out 42-0x20,r24
 273:../avr-lib/drivers/uart/uart.c ****     
 274:../avr-lib/drivers/uart/uart.c ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 275:../avr-lib/drivers/uart/uart.c ****     #ifdef URSEL
 276:../avr-lib/drivers/uart/uart.c ****     UCSRC = (1<<URSEL)|(3<<UCSZ0);
 268               	.LM27:
 269 00c6 86E8      		ldi r24,lo8(-122)
 270 00c8 80BD      		out 64-0x20,r24
 271               	/* epilogue: frame size=0 */
 272 00ca 0895      		ret
 273               	/* epilogue end (size=1) */
 274               	/* function uart_init size 24 (23) */
 276               	.Lscope2:
 278               	.global	uart_getc
 280               	uart_getc:
 277:../avr-lib/drivers/uart/uart.c ****     #else
 278:../avr-lib/drivers/uart/uart.c ****     UCSRC = (3<<UCSZ0);
 279:../avr-lib/drivers/uart/uart.c ****     #endif 
 280:../avr-lib/drivers/uart/uart.c ****     
 281:../avr-lib/drivers/uart/uart.c **** #elif defined (ATMEGA_USART0 )
 282:../avr-lib/drivers/uart/uart.c ****     /* Set baud rate */
 283:../avr-lib/drivers/uart/uart.c ****     if ( baudrate & 0x8000 ) 
 284:../avr-lib/drivers/uart/uart.c ****     {
 285:../avr-lib/drivers/uart/uart.c ****    		UART0_STATUS = (1<<U2X0);  //Enable 2x speed 
 286:../avr-lib/drivers/uart/uart.c ****    		baudrate &= ~0x8000;
 287:../avr-lib/drivers/uart/uart.c ****    	}
 288:../avr-lib/drivers/uart/uart.c ****     UBRR0H = (unsigned char)(baudrate>>8);
 289:../avr-lib/drivers/uart/uart.c ****     UBRR0L = (unsigned char) baudrate;
 290:../avr-lib/drivers/uart/uart.c **** 
 291:../avr-lib/drivers/uart/uart.c ****     /* Enable USART receiver and transmitter and receive complete interrupt */
 292:../avr-lib/drivers/uart/uart.c ****     UART0_CONTROL = _BV(RXCIE0)|(1<<RXEN0)|(1<<TXEN0);
 293:../avr-lib/drivers/uart/uart.c ****     
 294:../avr-lib/drivers/uart/uart.c ****     /* Set frame format: asynchronous, 8data, no parity, 1stop bit */
 295:../avr-lib/drivers/uart/uart.c ****     #ifdef URSEL0
 296:../avr-lib/drivers/uart/uart.c ****     UCSR0C = (1<<URSEL0)|(3<<UCSZ00);
 297:../avr-lib/drivers/uart/uart.c ****     #else
 298:../avr-lib/drivers/uart/uart.c ****     UCSR0C = (3<<UCSZ00);
 299:../avr-lib/drivers/uart/uart.c ****     #endif 
 300:../avr-lib/drivers/uart/uart.c **** 
 301:../avr-lib/drivers/uart/uart.c **** #elif defined ( ATMEGA_UART )
 302:../avr-lib/drivers/uart/uart.c ****     /* set baud rate */
 303:../avr-lib/drivers/uart/uart.c ****     if ( baudrate & 0x8000 ) 
 304:../avr-lib/drivers/uart/uart.c ****     {
 305:../avr-lib/drivers/uart/uart.c ****     	UART0_STATUS = (1<<U2X);  //Enable 2x speed 
 306:../avr-lib/drivers/uart/uart.c ****     	baudrate &= ~0x8000;
 307:../avr-lib/drivers/uart/uart.c ****     }
 308:../avr-lib/drivers/uart/uart.c ****     UBRRHI = (unsigned char)(baudrate>>8);
 309:../avr-lib/drivers/uart/uart.c ****     UBRR   = (unsigned char) baudrate;
 310:../avr-lib/drivers/uart/uart.c **** 
 311:../avr-lib/drivers/uart/uart.c ****     /* Enable UART receiver and transmitter and receive complete interrupt */
 312:../avr-lib/drivers/uart/uart.c ****     UART0_CONTROL = _BV(RXCIE)|(1<<RXEN)|(1<<TXEN);
 313:../avr-lib/drivers/uart/uart.c **** 
 314:../avr-lib/drivers/uart/uart.c **** #endif
 315:../avr-lib/drivers/uart/uart.c **** 
 316:../avr-lib/drivers/uart/uart.c **** }/* uart_init */
 317:../avr-lib/drivers/uart/uart.c **** 
 318:../avr-lib/drivers/uart/uart.c **** 
 319:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 320:../avr-lib/drivers/uart/uart.c **** Function: uart_getc()
 321:../avr-lib/drivers/uart/uart.c **** Purpose:  return byte from ringbuffer  
 322:../avr-lib/drivers/uart/uart.c **** Returns:  lower byte:  received byte from ringbuffer
 323:../avr-lib/drivers/uart/uart.c ****           higher byte: last receive error
 324:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 325:../avr-lib/drivers/uart/uart.c **** unsigned int uart_getc(void)
 326:../avr-lib/drivers/uart/uart.c **** {    
 282               	.LM28:
 283               	/* prologue: frame size=0 */
 284               	/* prologue end (size=0) */
 327:../avr-lib/drivers/uart/uart.c ****     unsigned char tmptail;
 328:../avr-lib/drivers/uart/uart.c ****     unsigned char data;
 329:../avr-lib/drivers/uart/uart.c **** 
 330:../avr-lib/drivers/uart/uart.c **** 
 331:../avr-lib/drivers/uart/uart.c ****     if ( UART_RxHead == UART_RxTail ) {
 286               	.LM29:
 287 00cc 9091 0000 		lds r25,UART_RxHead
 288 00d0 8091 0000 		lds r24,UART_RxTail
 289 00d4 9817      		cp r25,r24
 290 00d6 19F4      		brne .L16
 292               	.LM30:
 293 00d8 80E0      		ldi r24,lo8(256)
 294 00da 91E0      		ldi r25,hi8(256)
 295 00dc 0895      		ret
 296               	.L16:
 332:../avr-lib/drivers/uart/uart.c ****         return UART_NO_DATA;   /* no data available */
 333:../avr-lib/drivers/uart/uart.c ****     }
 334:../avr-lib/drivers/uart/uart.c ****     
 335:../avr-lib/drivers/uart/uart.c ****     /* calculate /store buffer index */
 336:../avr-lib/drivers/uart/uart.c ****     tmptail = (UART_RxTail + 1) & UART_RX_BUFFER_MASK;
 298               	.LM31:
 299 00de E091 0000 		lds r30,UART_RxTail
 300 00e2 EF5F      		subi r30,lo8(-(1))
 301 00e4 EF71      		andi r30,lo8(31)
 337:../avr-lib/drivers/uart/uart.c ****     UART_RxTail = tmptail; 
 303               	.LM32:
 304 00e6 E093 0000 		sts UART_RxTail,r30
 338:../avr-lib/drivers/uart/uart.c ****     
 339:../avr-lib/drivers/uart/uart.c ****     /* get data from receive buffer */
 340:../avr-lib/drivers/uart/uart.c ****     data = UART_RxBuf[tmptail];
 306               	.LM33:
 307 00ea FF27      		clr r31
 308 00ec E050      		subi r30,lo8(-(UART_RxBuf))
 309 00ee F040      		sbci r31,hi8(-(UART_RxBuf))
 310 00f0 2081      		ld r18,Z
 341:../avr-lib/drivers/uart/uart.c ****     
 342:../avr-lib/drivers/uart/uart.c ****     return (UART_LastRxError << 8) + data;
 312               	.LM34:
 313 00f2 8091 0000 		lds r24,UART_LastRxError
 314 00f6 9927      		clr r25
 315 00f8 982F      		mov r25,r24
 316 00fa 8827      		clr r24
 317 00fc 820F      		add r24,r18
 318 00fe 911D      		adc r25,__zero_reg__
 343:../avr-lib/drivers/uart/uart.c **** 
 344:../avr-lib/drivers/uart/uart.c **** }/* uart_getc */
 320               	.LM35:
 321 0100 0895      		ret
 322               	/* epilogue: frame size=0 */
 323               	/* epilogue: noreturn */
 324               	/* epilogue end (size=0) */
 325               	/* function uart_getc size 27 (27) */
 331               	.Lscope3:
 334               	.global	uart_putc
 336               	uart_putc:
 345:../avr-lib/drivers/uart/uart.c **** 
 346:../avr-lib/drivers/uart/uart.c **** 
 347:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 348:../avr-lib/drivers/uart/uart.c **** Function: uart_putc()
 349:../avr-lib/drivers/uart/uart.c **** Purpose:  write byte to ringbuffer for transmitting via UART
 350:../avr-lib/drivers/uart/uart.c **** Input:    byte to be transmitted
 351:../avr-lib/drivers/uart/uart.c **** Returns:  none          
 352:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 353:../avr-lib/drivers/uart/uart.c **** void uart_putc(unsigned char data)
 354:../avr-lib/drivers/uart/uart.c **** {
 338               	.LM36:
 339               	/* prologue: frame size=0 */
 340               	/* prologue end (size=0) */
 341 0102 282F      		mov r18,r24
 355:../avr-lib/drivers/uart/uart.c ****     unsigned char tmphead;
 356:../avr-lib/drivers/uart/uart.c **** 
 357:../avr-lib/drivers/uart/uart.c ****     
 358:../avr-lib/drivers/uart/uart.c ****     tmphead  = (UART_TxHead + 1) & UART_TX_BUFFER_MASK;
 343               	.LM37:
 344 0104 9091 0000 		lds r25,UART_TxHead
 345 0108 9F5F      		subi r25,lo8(-(1))
 346 010a 9F71      		andi r25,lo8(31)
 347               	.L21:
 359:../avr-lib/drivers/uart/uart.c ****     
 360:../avr-lib/drivers/uart/uart.c ****     while ( tmphead == UART_TxTail ){
 349               	.LM38:
 350 010c 8091 0000 		lds r24,UART_TxTail
 351 0110 9817      		cp r25,r24
 352 0112 E1F3      		breq .L21
 361:../avr-lib/drivers/uart/uart.c ****         ;/* wait for free space in buffer */
 362:../avr-lib/drivers/uart/uart.c ****     }
 363:../avr-lib/drivers/uart/uart.c ****     
 364:../avr-lib/drivers/uart/uart.c ****     UART_TxBuf[tmphead] = data;
 354               	.LM39:
 355 0114 E92F      		mov r30,r25
 356 0116 FF27      		clr r31
 357 0118 E050      		subi r30,lo8(-(UART_TxBuf))
 358 011a F040      		sbci r31,hi8(-(UART_TxBuf))
 359 011c 2083      		st Z,r18
 365:../avr-lib/drivers/uart/uart.c ****     UART_TxHead = tmphead;
 361               	.LM40:
 362 011e 9093 0000 		sts UART_TxHead,r25
 366:../avr-lib/drivers/uart/uart.c **** 
 367:../avr-lib/drivers/uart/uart.c ****     /* enable UDRE interrupt */
 368:../avr-lib/drivers/uart/uart.c ****     UART0_CONTROL    |= _BV(UART0_UDRIE);
 364               	.LM41:
 365 0122 559A      		sbi 42-0x20,5
 366               	/* epilogue: frame size=0 */
 367 0124 0895      		ret
 368               	/* epilogue end (size=1) */
 369               	/* function uart_putc size 18 (17) */
 374               	.Lscope4:
 377               	.global	uart_puts
 379               	uart_puts:
 369:../avr-lib/drivers/uart/uart.c **** 
 370:../avr-lib/drivers/uart/uart.c **** }/* uart_putc */
 371:../avr-lib/drivers/uart/uart.c **** 
 372:../avr-lib/drivers/uart/uart.c **** 
 373:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 374:../avr-lib/drivers/uart/uart.c **** Function: uart_puts()
 375:../avr-lib/drivers/uart/uart.c **** Purpose:  transmit string to UART
 376:../avr-lib/drivers/uart/uart.c **** Input:    string to be transmitted
 377:../avr-lib/drivers/uart/uart.c **** Returns:  none          
 378:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 379:../avr-lib/drivers/uart/uart.c **** void uart_puts(const char *s )
 380:../avr-lib/drivers/uart/uart.c **** {
 381               	.LM42:
 382               	/* prologue: frame size=0 */
 383 0126 CF93      		push r28
 384 0128 DF93      		push r29
 385               	/* prologue end (size=2) */
 386 012a EC01      		movw r28,r24
 387 012c 02C0      		rjmp .L27
 388               	.L28:
 381:../avr-lib/drivers/uart/uart.c ****     while (*s) 
 382:../avr-lib/drivers/uart/uart.c ****       uart_putc(*s++);
 390               	.LM43:
 391 012e 2196      		adiw r28,1
 392 0130 E8DF      		rcall uart_putc
 393               	.L27:
 395               	.LM44:
 396 0132 8881      		ld r24,Y
 397 0134 8823      		tst r24
 398 0136 D9F7      		brne .L28
 399               	/* epilogue: frame size=0 */
 400 0138 DF91      		pop r29
 401 013a CF91      		pop r28
 402 013c 0895      		ret
 403               	/* epilogue end (size=3) */
 404               	/* function uart_puts size 12 (7) */
 406               	.Lscope5:
 409               	.global	uart_puts_p
 411               	uart_puts_p:
 383:../avr-lib/drivers/uart/uart.c **** 
 384:../avr-lib/drivers/uart/uart.c **** }/* uart_puts */
 385:../avr-lib/drivers/uart/uart.c **** 
 386:../avr-lib/drivers/uart/uart.c **** 
 387:../avr-lib/drivers/uart/uart.c **** /*************************************************************************
 388:../avr-lib/drivers/uart/uart.c **** Function: uart_puts_p()
 389:../avr-lib/drivers/uart/uart.c **** Purpose:  transmit string from program memory to UART
 390:../avr-lib/drivers/uart/uart.c **** Input:    program memory string to be transmitted
 391:../avr-lib/drivers/uart/uart.c **** Returns:  none
 392:../avr-lib/drivers/uart/uart.c **** **************************************************************************/
 393:../avr-lib/drivers/uart/uart.c **** void uart_puts_p(const char *progmem_s )
 394:../avr-lib/drivers/uart/uart.c **** {
 413               	.LM45:
 414               	/* prologue: frame size=0 */
 415 013e CF93      		push r28
 416 0140 DF93      		push r29
 417               	/* prologue end (size=2) */
 418 0142 EC01      		movw r28,r24
 419 0144 01C0      		rjmp .L32
 420               	.L33:
 395:../avr-lib/drivers/uart/uart.c ****     register char c;
 396:../avr-lib/drivers/uart/uart.c ****     
 397:../avr-lib/drivers/uart/uart.c ****     while ( (c = pgm_read_byte(progmem_s++)) ) 
 398:../avr-lib/drivers/uart/uart.c ****       uart_putc(c);
 422               	.LM46:
 423 0146 DDDF      		rcall uart_putc
 424               	.L32:
 425 0148 FE01      		movw r30,r28
 426               	.LBB2:
 428               	.LM47:
 429 014a 2196      		adiw r28,1
 430               	/* #APP */
 431 014c 8491      		lpm r24, Z
 432               		
 433               	/* #NOAPP */
 434               	.LBE2:
 435 014e 8823      		tst r24
 436 0150 D1F7      		brne .L33
 437               	/* epilogue: frame size=0 */
 438 0152 DF91      		pop r29
 439 0154 CF91      		pop r28
 440 0156 0895      		ret
 441               	/* epilogue end (size=3) */
 442               	/* function uart_puts_p size 16 (11) */
 448               	.Lscope6:
 449               		.lcomm UART_TxBuf,32
 450               		.lcomm UART_RxBuf,32
 451               		.lcomm UART_TxHead,1
 452               		.lcomm UART_TxTail,1
 453               		.lcomm UART_RxHead,1
 454               		.lcomm UART_RxTail,1
 455               		.lcomm UART_LastRxError,1
 464               	.Letext0:
 465               	/* File "../avr-lib/drivers/uart/uart.c": code  176 = 0x00b0 ( 126), prologues  23, epilogues  27 *
DEFINED SYMBOLS
                            *ABS*:00000000 uart.c
     /tmp/ccG6wxDo.s:3      *ABS*:0000003f __SREG__
     /tmp/ccG6wxDo.s:4      *ABS*:0000003e __SP_H__
     /tmp/ccG6wxDo.s:5      *ABS*:0000003d __SP_L__
     /tmp/ccG6wxDo.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccG6wxDo.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccG6wxDo.s:86     .text:00000000 __vector_11
     /tmp/ccG6wxDo.s:452    .bss:00000042 UART_RxHead
     /tmp/ccG6wxDo.s:453    .bss:00000043 UART_RxTail
     /tmp/ccG6wxDo.s:449    .bss:00000020 UART_RxBuf
     /tmp/ccG6wxDo.s:454    .bss:00000044 UART_LastRxError
     /tmp/ccG6wxDo.s:163    .text:00000054 __vector_12
     /tmp/ccG6wxDo.s:450    .bss:00000040 UART_TxHead
     /tmp/ccG6wxDo.s:451    .bss:00000041 UART_TxTail
                             .bss:00000000 UART_TxBuf
     /tmp/ccG6wxDo.s:225    .text:0000009e uart_init
     /tmp/ccG6wxDo.s:280    .text:000000cc uart_getc
     /tmp/ccG6wxDo.s:336    .text:00000102 uart_putc
     /tmp/ccG6wxDo.s:379    .text:00000126 uart_puts
     /tmp/ccG6wxDo.s:411    .text:0000013e uart_puts_p

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
